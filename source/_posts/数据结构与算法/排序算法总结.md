---
title: 排序算法总结（附python代码）
date: 2021-01-13 21:11:50
tags: 数据结构与算法
---

UST这一学期算法课还是学了不少东西，从基础数据结构到排序、图、动态规划等等，算是让我这个传统工科人入门算法了。
一个月没怎么大量刷题又忘了不少，趁假期时间每天抽出一小时来总结这个数据结构与算法专题吧，毕竟大厂手撕算法是常态。
那就开始吧~
坚持 勤奋 挑战自我

### 一. 插入排序
时间复杂度：O(n×n)
像玩扑克牌抽牌整理牌一样，每插入一张纸牌做一次循环，每一次循环中将这张牌插入到合理的地方（大小顺序正确）
代码如下：
![](/images/数据结构与算法/插入排序.jpg)
改进的话可以当发现顺序正确时跳出这次循环


### 二. 冒泡排序
时间复杂度：O(n×n)
算法如其名，有多少个数就有多少个循环，每一次循环整个数组最小的数就会浮动到它应到的位置，第一轮找到最小的，第二轮找到第二小的以此类推，完成排序。
代码如下：
![](/images/数据结构与算法/冒泡排序.jpg)
也可以有下沉排序~


### 三. 快速排序
这里开始介绍了分治思想，就是把大的部分分成小的部分，处理之后再合并到一起，和递归联系到一起就有了接下来介绍的一些排序方式。
快速排序时间复杂度：O(n×log(n))   （这里指的就是平均了）
快速排序是将数组分成两个数组（一个数组里面的数都大于另一个数组），分别对这两个数组进行排序，再合并到一起就是一个排好序的数组。那么如何对分开的这两个数组排序呢，答案是分别对他们进行快速排序算法，那什么时候是个头呢，这也就是递归介绍的的最小不可再分割，直接返回的情况。
代码如下：
![](/images/数据结构与算法/快速排序.jpg)
如何将数组拆分成刚才说的两个数组呢，一般选第一个数作为pivot，比它大的一个数组，比它小的一个数组。所以第一个元素的大小直接影响了拆分情况，也就影响力算法时间复杂度。要是不走运数组已经排好序了那时间复杂度就是O(n×n)了。


### 四. 归并排序
刚才介绍的快速排序时间复杂度很不稳定，有没有什么算法时间复杂度比较稳定在O(n×log(n))呢？这里介绍归并排序
归并排序思想比较简单：
- 将数组分成两个数组
- 对每一个数组归并排序
- 将两个有序数组合并
代码如下：
![](/images/数据结构与算法/归并排序.jpg)
记住这里我们定义两个函数，第一函数就是分治思想，将数组分割，排序，合并；第二个函数就是具体的如何将两个有序列表合并的过程。


### 五. 堆排序
什么是堆呢，这里其实就是一个数组，不过我们把里面的元素想象在一个二叉树里面。什么是最大堆呢，就是指每一个根节点的数都比他子节点的数大，也就是说最上面的根节点数值是最大的，最小堆同理。那么怎么做堆排序呢，很简单，因为最顶端的数是最大的，所以他肯定排在最后一位，我们就把他拿出来放到最后，那其他的元素怎么办呢？我们再重新将它们排列成最大堆，再将最上面的元素移到倒数第二个，以此类推不断重复直到最后一个，就完成了。
堆排序时间复杂度：O(n×log(n))
建堆的时间复杂度：O(n)
先看代码：
![](/images/数据结构与算法/堆排序.jpg)
解释一下，代码分为两部分，先说heapify函数部分，这个函数很简单，就是刚才说的将根节点和他的两个子节点比较，如果子节点比他大就选最大的那个子节点跟他交换保证这三个元素是最大堆，之后在后面加一个递归，继续heapify被交换过来的那个子节点（原来的根节点），什么时候停止呢，当这个根节点已经最大了就可以停止了。那问题来了，怎么保证后面的节点都满足最大堆呢？这里再来看第一个函数heapsort()，上来我们就来了个遍历，保证这个堆最开始就是一个最大堆（要从后往前遍历才能保证上面的永远是最大的）。这样我们将最上面的元素跟最后面的交换，数组最后一个数就是最大的，前面的那些元素虽然不是最大堆了但是因为之前刚刚遍历一次heapify所以不混乱，也就是说只有根节点也就是刚刚被换过来的那个节点打乱了顺序，我们将它放到heapify函数，就可以保证很快的再建最大堆。多次循环，完成堆排序。


### 六. 二叉搜索树
二叉搜索树排序时间复杂度：O(n×log(n))
什么是二叉搜索树：首先是一个二叉树，且满足左子节点的值小于等于根节点，右子节点的值大于等于根节点，这样的一棵树成为二叉搜索树。利用二叉搜索树排序就可以构建树之后中序遍历输出就好了。如何构建二叉搜索树呢？树的“尾巴”太长怎么办呢？平衡树和红黑树是什么呢？这些问题我之后再单独开一个树的数据结构专题总结。


### 七. 计数排序
时间复杂度：O(n+k)
这个排序方法非常巧妙，原理是计算每个元素出现的次数，再将出现过的元素一个一个打印出来，记录时从0开始准备好每一个“连续数”的初始出现次数 —— 0，之后每出现一次增加1，完成计数排序。
代码如下：
![](/images/数据结构与算法/计数排序.jpg)
不过有一个问题，当这个数组里面最大的数很大时，就要构造一个很大的数组来记录，这是资源与时间的浪费，所以这也是他的弊端。

### 八. 基数排序
刚才介绍了非常巧妙的计数排序